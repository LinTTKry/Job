# 宏任务和微任务：不是所有任务都是一个待遇

## ​宏任务

前面我们已经介绍过了，页面中的大部分任务都是在主线程上执行的，这些任务包括了：

* 渲染事件（如解析 DOM、计算布局、绘制）；
* 用户交互事件（如鼠标点击、滚动页面、放大缩小等）；
* JavaScript 脚本执行事件；
* 网络请求完成、文件读写完成事件。

为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。<mark style="color:red;">**然后主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为宏任务。**</mark>

消息队列中的任务是通过事件循环系统来执行的，这里我们可以看看在[WHATWG 规范](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)中是怎么定义事件循环机制的。这里我就大致总结了下 WHATWG 规范定义的大致流程：

* 先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask；
* 然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务；
* 当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 oldestTask；
* 最后统计执行完成的时长等信息。

以上就是消息队列中宏任务的执行过程。

页面的渲染事件、各种 IO 的完成事件、执行 JavaScript 脚本的事件、用户交互的事件等都随时有可能被添加到消息队列中，<mark style="color:blue;">而且添加事件是由系统操作的，JavaScript 代码不能准确掌控任务要添加到队列中的位置，控制不了任务在消息队列中的位置，所以很难控制开始执行任务的时间</mark>。
