# 输入url发生了什么？

### 1. DNS将域名解析为IP地址；

* 查找浏览器缓存，无则下一步
* 查找系统缓存，无则下一步
* 查找路由缓存，无则下一步
* 查找ISP缓存，无责下一步
* 递归查询：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。
* 迭代查询：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。 然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。

### 2. 发起TCP的三次握手；

* 第一次握手：客户端发送一个TCP的SYN标志位置为1的包，指明客户端打算连接，以及初始序列号X,保存在包头的序列号（Sequence Number）的字段里。
* 服务器发回确认包（ACK）。即SYN和ACK的标志位1，并且将自己的序列号放到Seq域里，同时将确认序号设置为客户端的序列号加1。
* 客户端再次发送确认包。SYN的标志位0，ACK的标志位1，并将确认序号设置为服务端序列号加1。

![](<../.gitbook/assets/image (39).png>)

### 3. 发送http的请求报文；

* 请求行：method+url+http版本号
* 请求头
* 空行
* 请求体

### 4. 收到服务器发送的响应报文；

* 响应行：http版本号+状态码+状态原因短语
* 响应头
* 空行
* 响应体

### 5. 生成DOM和css规则树，合并为渲染树，接着进入到布局阶段，也就是为每个节点分配一个应在屏幕出现的确切坐标；

### 6. 随后调用GPU进行绘制，遍历render tree的节点，将元素呈现出来

### 7. 传输完毕断开连接（四次挥手）；

* 客户端发送一个FIN标志位为1的包，表示自己没有数据可发送
* 服务器发送确认包，表明自己接受了关闭请求，但还没有准备好。
* 服务器准备好关闭，发送FIN标志位为1的包；
* 客户端发送确认包，进入TIME-WAIT的阶段，等待可能出现要求重传的ACK包
* 客户端等待固定时间（两个最大段的生命周期）之后，没有接到服务端发送的ACK包，认为服务器正常关闭，于是自己也关于连接。

![](<../.gitbook/assets/image (38).png>)
