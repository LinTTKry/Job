# 垃圾回收：垃圾数据是如何自动回收的？

## ​调用栈中的数据是如何回收的

```javascript
function foo(){
    var a = 1
    var b = {name:"极客邦"}
    function showName(){
      var c = 2
      var d = {name:"极客时间"}
    }
    showName()
}
foo()
```

![](<../../.gitbook/assets/image (91) (1).png>)

如果执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，其调用栈就如上图所示。<mark style="color:red;">**与此同时，还有一个记录当前执行状态的指针（称为 ESP），指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。**</mark>

接着，当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。ESP 这时候就帮上忙了，JavaScript 会将 ESP 下移到 foo 函数的执行上下文，这个下移操作就是销毁 showName 函数执行上下文的过程。

![](<../../.gitbook/assets/image (90) (1).png>)

<mark style="color:red;">**当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。**</mark>

## 堆中的数据是如何回收的

当上面那段代码的 foo 函数执行结束之后，ESP 应该是指向全局执行上下文的，那这样的话，showName 函数和 foo 函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间

![](<../../.gitbook/assets/image (86).png>)

### 一、代际假说&#x20;

1、大部分对象存活时间很短&#x20;

2、不被销毁的对象，会活的更久

### 二、新生代 与老生代

分类 V8 中会把<mark style="color:red;">**堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象**</mark>。

副垃圾回收器，主要负责新生代（1-8M的容量）的垃圾回收。

主垃圾回收器，主要负责老生代（大容量）的垃圾回收。

#### 1、新生代 （副垃圾回收器）

算法：Scavenge 算法&#x20;

![](<../../.gitbook/assets/image (60).png>)

原理：&#x20;

1、把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。

2、新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。&#x20;

3、先对对象区域中的垃圾做标记，<mark style="color:blue;">**标记完成之后，把这些存活的对象复制到空闲区域中**</mark>&#x20;

4、完成复制后，<mark style="color:blue;">**对象区域与空闲区域进行角色翻转**</mark>，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。&#x20;

对象晋升策略： 经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

#### 2、老生代 （主垃圾回收器）

算法：标记 - 清除（Mark-Sweep）算法&#x20;

原理： 1、标记：标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。 2、清除：将垃圾数据进行清除。 碎片： 对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存。

算法：标记 - 整理（Mark-Compact）算法&#x20;

原理：&#x20;

1、标记：和标记 - 清除的标记过程一样，从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素标记为活动对象。

2、整理：让所有存活的对象都向内存的一端移动&#x20;

3、清除：清理掉端边界以外的内存

优化算法：增量标记（Incremental Marking）算法

V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。

![](<../../.gitbook/assets/image (61).png>)

&#x20;原理：&#x20;

1、为了降低老生代的垃圾回收而造成的卡顿&#x20;

2、V8把一个完整的垃圾回收任务拆分为很多小的任务&#x20;

3、让垃圾回收标记和 JavaScript 应用逻辑交替进行

<mark style="color:red;">****</mark>
