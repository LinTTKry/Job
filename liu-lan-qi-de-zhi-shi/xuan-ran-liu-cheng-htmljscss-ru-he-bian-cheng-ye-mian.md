# 渲染流程：html、js、css如何变成页面

## 1：定义

## ​![](<../.gitbook/assets/image (61) (1) (1) (1).png>)

**HTML** 的内容是由**标记（标签）和文本**组成；

**CSS** 又称为层叠样式表，是由**选择器和属性**组成；

**JavaScript**（简称为 JS），**使用它可以使网页的内容“动”起来**，比如上图中，可以通过 JavaScript 来修改 CSS 样式值，从而达到修改文本颜色的目的。

## ​2：渲染流水线

![](<../.gitbook/assets/9259f8732ddad472e5e08a633ad46de8 (1).webp>)

流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。

开始每个子阶段都有其输入的内容；

然后每个子阶段有其处理过程；

最终每个子阶段会生成输出内容。

### A. 构建DOM树

这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树

![​](../.gitbook/assets/9259f8732ddad472e5e08a633ad46de8.webp)

为了更加直观地理解 DOM 树，你可以打开 Chrome 的“开发者工具”，选择“Console”标签来打开控制台，然后在控制台里面输入“document”后回车，这样你就能看到一个完整的 DOM 树结构，如下图所示：

![](<../.gitbook/assets/image (60) (1) (1).png>)

DOM 可视化图中的 document 就是 DOM 结构，你可以看到，DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。那下面就来看看如何通过 JavaScript 来修改 DOM 的内容，在控制台中输入：

```javascript
document.getElementsByTagName("p")[0].innerText = "black"
```

这行代码的作用是把第一个标签的内容修改为 black，具体执行结果你可以参考下图：

![](<../.gitbook/assets/image (65) (1) (1) (1).png>)

通过 JavaScript 修改 DOM从图中可以看出，在执行了一段修改第一个标签的 JavaScript 代码后，DOM 的第一个 p 节点的内容成功被修改，同时页面中的内容也被修改了。好了，现在我们已经生成 DOM 树了，但是 DOM 节点的样式我们依然不知道，要让 DOM 节点拥有正确的样式，这就需要样式计算了。

### B.样式计算（Recalculate Style）

* [ ] 把 CSS 转换为浏览器能够理解的结构

![](<../.gitbook/assets/image (63) (1) (1).png>)

和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。为了加深理解，你可以在 Chrome 控制台中查看其结构，只需要在控制台中输入 document.styleSheets，然后就看到如下图所示的结构：

![](<../.gitbook/assets/image (58) (1) (1).png>)

从图中可以看出，这个样式表包含了很多种样式，已经把那三种来源的样式都包含进去了。当然样式表的具体结构不是我们今天讨论的重点，你只需要知道渲染引擎会把获取到的 CSS 文本全部转换为 styleSheets 结构中的数据，并且该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础。

* [ ] 转换样式表中的属性值，使其标准化

那么接下来就要对其进行属性值的标准化操作, 要理解什么是属性值标准化，你可以看下面这样一段 CSS 文本：

```javascript
body { font-size: 2em } 
p {color:blue;}
span {display: none} 
div {font-weight: bold}
div p {color:green;} 
div {color:red; }
```

可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。

![](<../.gitbook/assets/image (6) (1) (1).png>)

* [ ] 计算出 DOM 树中每个节点的具体样式

这就涉及到 CSS 的继承规则和层叠规则了。首先是 CSS 继承。CSS 继承就是每个 DOM 节点都包含有父节点的样式。这么说可能有点抽象，我们可以结合具体例子，看下面这样一张样式表是如何应用到 DOM 节点上的。body { font-size: 20px }

```javascript
p {color:blue;}
span  {display: none}
div {font-weight: bold;color:red}
div  p {color:green;}
```

这张样式表最终应用到 DOM 节点的效果如下图所示：

![](<../.gitbook/assets/image (62) (1) (1) (1).png>)

从图中可以看出，所有子节点都继承了父节点样式。比如 body 节点的 font-size 属性是 20，那 body 节点下面的所有节点的 font-size 都等于 20。为了加深你对 CSS 继承的理解，你可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，再选择“style”子标签，你会看到如下界面：

![](<../.gitbook/assets/image (64) (1) (1).png>)

样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。

### C. 布局阶段

* [ ] 创建布局树

&#x20;你可能注意到了 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。我们结合下图来看看布局树的构造过程：

![](<../.gitbook/assets/image (79) (1) (1) (1) (1).png>)

DOM 树中所有不可见的节点都没有包含到布局树中。为了构建布局树，浏览器大体上完成了下面这些工作：遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。

* [ ] 布局计算

计算每个元素的几何坐标位置，并将这些信息保存在布局树中

### D. 分层

现在我们有了布局树，而且每个元素的具体位置信息都计算出来了，那么接下来是不是就要开始着手绘制页面了？答案依然是否定的。因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。<mark style="color:blue;">浏览器的页面</mark><mark style="color:blue;">**实际上被分成了很多图层，这些图层叠加后合成了最终的页面。**</mark>

****![](<../.gitbook/assets/image (70) (1) (1).png>)****

通常情况下，_<mark style="color:blue;">并不是布局树的每个节点都包含一个图层</mark>_，_<mark style="color:blue;">如果一个节点没有对应的层，那么这个节点就从属于父节点的图层</mark>_。如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。

通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层**:**

* 页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。
* 需要剪裁（clip）的地方也会被创建为图层

```javascript
<style>
      div {
            width: 200;
            height: 200;
            overflow:auto;
            background: gray;
        } 
</style>
<body>
    <div >
        <p>所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：</p>
        <p>从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。</p>
        <p>图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。</p> 
    </div>
</body>
```

在这里我们把 div 的大小限定为 200 \* 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200 \* 200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域，下图是运行时的执行结果：

![](<../.gitbook/assets/image (59) (1).png>)

出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。

![](<../.gitbook/assets/image (58) (1).png>)

### E. 图层绘制

渲染引擎实现图层的绘制与之类似，<mark style="color:blue;">**会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表**</mark>，如下图所示：

![](<../.gitbook/assets/image (71) (1).png>)

你也可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘制列表，如下图所示：

![](<../.gitbook/assets/image (77) (1) (1) (1).png>)

一个图层的绘制列表在该图中，区域 1 就是 document 的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程。

### F.栅格化

绘制列表只是用来记录绘制顺序和绘制指令的列表，<mark style="color:blue;">**而实际上绘制操作是由渲染引擎中的合成线程来完成的**</mark>。你可以结合下图来看下渲染主线程和合成线程之间的关系：

![](<../.gitbook/assets/image (69) (1) (1).png>)

在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要<mark style="color:blue;">**绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要**</mark>。基于这个原因，<mark style="color:blue;">**合成线程会将图层划分为图块（tile）**</mark>，这些图块的大小通常是 256x256 或者 512x512，如下图所示：

![](<../.gitbook/assets/image (63) (1).png>)

然后合成线程会按照<mark style="color:blue;">**视口附近的图块来优先生成位图**</mark>，实际生成位图的操作是由栅格化来执行的。<mark style="color:blue;">**所谓栅格化，是指将图块转换为位图**</mark>。而图块是栅格化执行的最小单位。<mark style="color:blue;">**渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的**</mark>，运行方式如下图所示：

![](<../.gitbook/assets/image (65) (1) (1).png>)

通常，<mark style="color:blue;">**栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化**</mark>，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了<mark style="color:blue;">**跨进程操作**</mark>。

![](<../.gitbook/assets/image (72) (1).png>)

从图中可以看出，<mark style="color:blue;">**渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中**</mark>。

### G. 合成和显示

一旦所有图块都被光栅化，合<mark style="color:blue;">**成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上**</mark>。到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。

## 3. 渲染流水线总结

![](<../.gitbook/assets/image (78) (1) (1) (1) (1).png>)

### A. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。

### B. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。

### C. 创建布局树，并计算元素的布局信息。

### D. 对布局树进行分层，并生成分层树。

### E.为每个图层生成绘制列表，并将其提交到合成线程。

### F. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。

### G. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。

### H. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

## 4. 重排

如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性

![](<../.gitbook/assets/image (76) (1) (1).png>)

如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。

## 5. 重绘

果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换

![](<../.gitbook/assets/image (68) (1) (1).png>)

重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。

## 6. 直接合成阶段

染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成

![](<../.gitbook/assets/image (61) (1).png>)

在上图中，我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。
