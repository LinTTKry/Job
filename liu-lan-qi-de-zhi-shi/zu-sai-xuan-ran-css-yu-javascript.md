# 阻塞渲染：CSS 与 javascript

## &#x20;**渲染的主要过程**

![](<../.gitbook/assets/image (42).png>)

**注意：渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render tree。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容**

## CSS阻塞渲染的原因

如果`CSS` 不会阻塞页面阻塞渲染，那么`CSS`文件下载之前，浏览器就会渲染出一个浅绿色的`div`，之后再变成浅蓝色。浏览器的这个策略其实很明智的，想象一下，如果没有这个策略，页面首先会呈现出一个原始的模样，待`CSS`下载完之后又突然变了一个模样。用户体验可谓极差，而且渲染是有成本的。

因此，基于性能与用户体验的考虑，浏览器会尽量减少渲染的次数，`CSS`顺理成章地阻塞页面渲染。

## `JS` 阻塞 `DOM` 解析

浏览器并不知道脚本的内容是什么，如果先行解析下面的`DOM`，万一脚本内全删了后面的`DOM`，浏览器就白干活了。更别谈丧心病狂的`document.write`。浏览器无法预估里面的内容，那就干脆全部停住，等脚本执行完再干活就好了。

对此的优化其实也很显而易见，具体分为两类。如果`JS`文件体积太大，同时你确定没必要阻塞`DOM`解析的话，不妨按需要加上`defer`或者`async`属性，此时脚本下载的过程中是不会阻塞`DOM`解析的。\


现代的浏览器很聪明，它会“偷看”之后的`DOM`内容，碰到如`<link>`、`<script>`和`<img>`等标签时，它会帮助我们先行下载里面的资源，不会傻等到解析到那里时才下载

## 阻塞

当HTML解析器（HTML Parser） **被脚本阻塞时**，解析器虽然**会停止构建DOM**，但仍会识别该脚本后面的资源，并**进行预加载**。

同时，由于下面两点：

1. 默认情况下，CSS 被视为阻塞渲染的资源，这意味着浏览器不会渲染任何已处理的内容，直至CSSOM构建完毕
2. javascript 不仅可以读取和修改DOM 属性，还可以读取和修改CSSOM 属性

存在阻塞的 CSS 资源时， 浏览器会延迟javascript 的执行和 Render Tree 构建。

另外

1. 当浏览器遇到一个script标记时，DOM 构建将暂停，直至脚本完成执行。
2. javascript 可以查询和修改 DOM 与 CSSOM
3. CSSOM 构建时，javascript 执行将暂停，直至 CSSOM 就绪。

所以，script 标签的位置很重要。实际使用时，可以遵循下面2个原则

1. **CSS 优先：引入顺序上，CSS 资源优于javascript资源**
2. **javascript 应尽量少影响 DOM 的构建**
