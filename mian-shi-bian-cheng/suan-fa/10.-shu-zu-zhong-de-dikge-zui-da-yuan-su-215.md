---
description: 桶排序，最大堆
---

# 03.数组中的第K个最大元素215

在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

**示例 1:**

```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```

**说明:**

你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。

{% hint style="info" %}
1：构建最小堆&#x20;

2：交换len-1-k次；&#x20;

3：nums\[0]就是最小值
{% endhint %}

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
    const len = nums.length;
    buildMaxHeap(nums);
    for(var i = len-1; i>=k; i--){
        [nums[0],nums[i]] = [nums[i],nums[0]];
        heapify(nums,0,i)
    }
    return nums[0]
}
function buildMaxHeap(nums){
   if(nums.length<=1) return nums;
   let middle = Math.floor(nums.length/2);
   for(let i = middle; i>=0; i--){
       heapify(nums,i,nums.length)
   }
}
function heapify(nums,i,len){
    let left = 2*i+1, right = 2*i+2,largest = i;
    if(left<len && nums[left]<nums[largest])largest = left
    if(right<len && nums[right]<nums[largest])largest = right;
    if(largest!=i){
        [nums[largest],nums[i]]=[nums[i],nums[largest]];
        heapify(nums,largest,len)
    }
}
```
