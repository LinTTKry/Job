# 00.斐波那契数

斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：F(0) = 0，F(1) = 1F(n) = F(n - 1) + F(n - 2)，其中 n > 1来源：力扣（LeetCode）链接：[https://leetcode-cn.com/problems/fibonacci-number著作权](https://leetcode-cn.com/problems/fibonacci-number%E8%91%97%E4%BD%9C%E6%9D%83)

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var fib = function(n) {
    const fn = [n+1];
    fn[0] = 0
    fn[1] = 1;
    for(let i = 2; i <= n; i++){
        fn[i] = fn[i-1]+fn[i-2]
    }
    return fn[n]
};
```

​f(100)时浏览器就会卡死（栈溢出）

另外，可以通过编写一个方法计算js函数调用栈的最深层级的大小

```javascript
var callbackNum = function (n){
   try{
      return 1 + computeMaxCallStackSize();
   }catch(e){
      return 1
   }
}
console.log(callbackNum())
```

**改为尾调优化的写法**

****[**https://www.ruanyifeng.com/blog/2015/04/tail-call.html**](https://www.ruanyifeng.com/blog/2015/04/tail-call.html)****

尾调用不一定出现在函数尾部，只要是最后一步操作即可

尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。



> ```
> function f() {
>   let m = 1;
>   let n = 2;
>   return g(m + n);
> }
> f();
>
> // 等同于
> function f() {
>   return g(3);
> }
> f();
>
> // 等同于
> g(3);
> ```

上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f() 的调用记录，只保留 g(3) 的调用记录。

这就叫做"尾调用优化"（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是"尾调用优化"的意义

递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生"栈溢出"错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生"栈溢出"错误。

思路： 使用两个临时变量来存储上一个值，和上上个值

```
function fTail(n, ac1=0, ac2=1){
    if(n===0){
    return ac1
  }else
      return fTail(n-1, ac2, ac1+ac2)
}

fTail(100)
// 354224848179262000000
fTail(1000)
// 4.346655768693743e+208
fTail(2000)
// Infinity
```

理论上，如果尾调优化有效，上述代码应该能一直计算(即使输出Infinity)，但Chrome 72中实际测试表明大概计算到 fTail(7370) 时报错 Maxinum call stack size exceeded尾调优化主要有两点问题，导致它的提案仍没有完全通过，浏览器的支持也不统一：

* 在引擎层面进行尾调优化是一个隐式行为，如果代码存在死循环尾递归调用，可能因为优化后没有爆栈报错提示而无法被程序员察觉
* 优化后，调用堆栈信息会丢失，造成调试困难

### 严格模式

ES6的尾调用优化只在严格模式下开启，正常模式是无效的。

这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。

> * `arguments`：返回调用时函数的参数。
> * `func.caller`：返回调用当前函数的那个函数。

尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。

#### 改用循环重写

所有递归都可以转化为循环编写

思路： 类似上一个例子，Fibonacci数列的实现使用循环还是比较简单



```
function fLoop(n) {  
  let a1 = 0, a2 = 1;
  while(n--){
      [a1,a2] = [a2,a1+a2]
  }
  return a1
}
console.log(fLoop(100))
// 354224848179262000000
console.log(fLoop(1000))
// 4.346655768693743e+208
console.log(fLoop(2000))
// Infinity
```
