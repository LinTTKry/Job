# 02. 二叉树的层序遍历102

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

**示例：**\
二叉树：`[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其层序遍历结果：

```
[
  [3],
  [9,20],
  [15,7]
]
```

{% hint style="info" %}
1: 广度优先，在层上遍历，遍历条件为当前的queue数组长度；并且在每次push结果的时候，要为下一层遍历做准备，即将当前节点的left,right顺序放入queue中；
{% endhint %}

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
   if(!root) return [];
   let res = []
   let queue = [root];
   while(queue.length>0){
       let arr = [];
       let len = queue.length;
       while(len--){
           let node = queue.shift();
           arr.push(node.val);
           if(node.left) queue.push(node.left)
           if(node.right) queue.push(node.right)
       }
       res.push(arr)
   }
   return res
}
```

{% hint style="info" %}
2：深度优先：指定层级就好
{% endhint %}

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if(!root) return [];
    let res = [];
    dfs(root,res,0);
    return res;
}
function dfs (root, res, layer){
    if(root){
        if(!res[layer])res[layer]=[];
        res[layer].push(root.val);
        dfs(root.left,res,layer+1)
        dfs(root.right,res,layer+1)
    }
}
```
